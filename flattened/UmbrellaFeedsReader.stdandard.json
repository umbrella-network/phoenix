{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IUmbrellaFeeds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev Main contract for all deviation triggered fees.\n/// This contract has build in fallback feature in case it will be replaced by newer version.\n/// Fallback is transparent for the user, no additional setup is needed.\n///\n/// How fallback feature works? If data for provided key is empty, contract will execute following procedure:\n/// 1. triggered feeds, that needs to be updated will be updated in new contract and erased from this one\n/// 2. if data is empty, check, if new deployment of UmbrellaFeeds is done, if not stop.\n/// 3. forward the call to that new contract.\n///\n/// After new deployment done it is recommended to update address to avoid fallback and reduce gas cost.\n/// In long run this is most efficient solution, better than any proxy.\ninterface IUmbrellaFeeds {\n    struct PriceData {\n        uint8 data;\n        uint24 heartbeat;\n        uint32 timestamp;\n        uint128 price;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @dev method for submitting consensus data\n    /// @param _priceKeys array of keys for `_priceDatas`\n    /// @param _priceDatas PriceData signed by validators\n    /// @param _signatures validators signatures\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function update(\n        bytes32[] calldata _priceKeys,\n        PriceData[] calldata _priceDatas,\n        Signature[] calldata _signatures\n    ) external;\n\n    /// @dev method for resetting data\n    /// @param _priceKeys array of keys for `_priceDatas`\n    /// @param _signatures validators signatures\n    function reset(bytes32[] calldata _priceKeys, Signature[] calldata _signatures) external;\n\n    /// @dev it will return array of price datas for provided `_keys`\n    /// In case ony of feeds timestamp is empty, fallback call will be executed for that feed.\n    /// If any of feeds fallback calls fail, function will revert.\n    /// @param _keys array of feed keys\n    /// @return data PriceData array\n    function getPricesData(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev same as getPricesData() but does not revert on empty data.\n    function getPricesDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev this is main endpoint for reading feeds.\n    /// In case timestamp is empty (that means there is no data), contract will execute fallback call.\n    /// Check contract description for fallback details.\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data);\n\n    /// @dev same as `getPriceData` but does not revert when no data\n    function getPriceDataRaw(bytes32 _key) external view returns (PriceData memory data);\n\n    function DECIMALS() external view returns (uint8); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/onChainFeeds/UmbrellaFeedsReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/IUmbrellaFeeds.sol\";\n\n/// @dev This is optional price reader for just one feed.\n/// It comes with chanilink interface that makes migration process easier.\n/// For maximum gas optimisation it is recommended to use UmbrellaFeeds directly.\ncontract UmbrellaFeedsReader {\n    /// @dev contract where all the feeds are stored\n    IUmbrellaFeeds public immutable UMBRELLA_FEEDS;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev key (hash of string key), under which feed is being stored\n    bytes32 public immutable KEY;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev decimals for feed\n    uint8 public immutable DECIMALS;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev string representation of feed key\n    string public DESCRIPTION;  // solhint-disable-line var-name-mixedcase\n\n    error FeedNotExist();\n\n    /// @param _umbrellaFeeds UmbrellaFeeds address\n    /// @param _key price data key (before hashing)\n    constructor(IUmbrellaFeeds _umbrellaFeeds, string memory _key) {\n        UMBRELLA_FEEDS = _umbrellaFeeds;\n        DESCRIPTION = _key;\n        DECIMALS = _umbrellaFeeds.DECIMALS();\n\n        bytes32 hash = keccak256(abi.encodePacked(_key));\n        KEY = hash;\n\n        // sanity check\n        _umbrellaFeeds.getPriceData(hash);\n    }\n\n    /// @dev decimals for feed\n    function decimals() external view returns (uint8) {\n        return DECIMALS;\n    }\n\n    /// @dev string representation of feed key\n    function description() external view returns (string memory) {\n        return DESCRIPTION;\n    }\n\n    /// @dev this method follows chainlink interface for easy migration, NOTE: not all returned data are covered!\n    /// latestRoundData() raise exception when there is no data, instead of returning unset values,\n    /// which could be misinterpreted as actual reported values.\n    /// It DOES NOT raise when data is outdated (based on heartbeat and last timestamp).\n    /// @notice You can save some gas by doing call directly to `UMBRELLA_FEEDS` contract.\n    /// @return uint80 originally `roundId`, not in use, always 0\n    /// @return answer price\n    /// @return uint256 originally `startedAt`, not in use, always 0\n    /// @return updatedAt last timestamp data was updated\n    /// @return uint80 originally `answeredInRound` not in use, always 0\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 /* roundId */,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        )\n    {\n        IUmbrellaFeeds.PriceData memory data = UMBRELLA_FEEDS.getPriceData(KEY);\n        return (0, int256(uint256(data.price)), 0, data.timestamp, 0);\n    }\n\n    /// @dev this is main endpoint for reading feed. Feed is read from UmbrellaFeeds contract using hardcoded `KEY`.\n    /// In case timestamp is empty (that means there is no data), contract will execute fallback call.\n    /// Check UmbrellaFeeds contract description for fallback details.\n    function getPriceData() external view returns (IUmbrellaFeeds.PriceData memory) {\n        return UMBRELLA_FEEDS.getPriceData(KEY);\n    }\n\n    /// @dev same as `getPriceData` but does not revert when no data\n    function getPriceDataRaw() external view returns (IUmbrellaFeeds.PriceData memory) {\n        return UMBRELLA_FEEDS.getPriceDataRaw(KEY);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 0
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}