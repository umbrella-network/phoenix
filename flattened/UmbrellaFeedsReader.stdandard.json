{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n\ninterface IRegistry {\n    event LogRegistered(address indexed destination, bytes32 name);\n\n    /// @dev imports new contract addresses and override old addresses, if they exist under provided name\n    /// This method can be used for contracts that for some reason do not have `getName` method\n    /// @param  _names array of contract names that we want to register\n    /// @param  _destinations array of contract addresses\n    function importAddresses(bytes32[] calldata _names, address[] calldata _destinations) external;\n\n    /// @dev imports new contracts and override old addresses, if they exist.\n    /// Names of contracts are fetched directly from each contract by calling `getName`\n    /// @param  _destinations array of contract addresses\n    function importContracts(address[] calldata _destinations) external;\n\n    /// @dev this method ensure, that old and new contract is aware of it state in registry\n    /// Note: BSC registry does not have this method. This method was introduced in later stage.\n    /// @param _newContract address of contract that will replace old one\n    function atomicUpdate(address _newContract) external;\n\n    /// @dev similar to `getAddress` but throws when contract name not exists\n    /// @param name contract name\n    /// @return contract address registered under provided name or throws, if does not exists\n    function requireAndGetAddress(bytes32 name) external view returns (address);\n\n    /// @param name contract name in a form of bytes32\n    /// @return contract address registered under provided name\n    function getAddress(bytes32 name) external view returns (address);\n\n    /// @param _name contract name\n    /// @return contract address assigned to the name or address(0) if not exists\n    function getAddressByString(string memory _name) external view returns (address);\n\n    /// @dev helper method that converts string to bytes32,\n    /// you can use to to generate contract name\n    function stringToBytes32(string memory _string) external pure returns (bytes32 result);\n}\n"
    },
    "contracts/interfaces/IUmbrellaFeeds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUmbrellaFeeds {\n    struct PriceData {\n        /// @dev this is placeholder, that can be used for some additional data\n        /// atm of creating this smart contract, it is only used as marker for removed data (when == type(uint8).max)\n        uint8 data;\n        /// @dev heartbeat: how often price data will be refreshed in case price stay flat\n        uint24 heartbeat;\n        /// @dev timestamp: price time, at this time validators run consensus\n        uint32 timestamp;\n        /// @dev price\n        uint128 price;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @dev method for submitting consensus data\n    /// @param _priceKeys array of keys for `_priceDatas`\n    /// @param _priceDatas PriceData signed by validators\n    /// @param _signatures validators signatures\n    function update(\n        bytes32[] calldata _priceKeys,\n        PriceData[] calldata _priceDatas,\n        Signature[] calldata _signatures\n    ) external;\n\n    /// @dev it will return array of price datas for provided `_keys`\n    /// In case ony of feed does not exist, fallback call will be executed for that feed.\n    /// @notice If data for any key not exists, function will revert. Use `getManyPriceDataRaw` method if you don't\n    /// want revert.\n    /// @param _keys array of feed keys\n    /// @return data PriceData array\n    function getManyPriceData(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev same as getManyPriceData() but does not revert on empty data.\n    /// @notice This method does no revert if some data does not exists.\n    /// Check `data.timestamp` to see if price exist, if it is 0, then it does not exist.\n    function getManyPriceDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev this is main endpoint for reading feeds.\n    /// In case timestamp is empty (that means there is no data), contract will revert.\n    /// If you do not need whole data from `PriceData` struct, you can save some gas by using other view methods that\n    /// returns just what you need.\n    /// @notice method will revert if data for `_key` not exists.\n    /// @param _key hash of feed name\n    /// @return data full PriceData struct\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data);\n\n    /// @notice reader for mapping\n    /// @param _key hash of feed name\n    /// @return data full PriceData struct\n    function prices(bytes32 _key) external view returns (PriceData memory data);\n\n    /// @notice method will revert if data for `_key` not exists.\n    /// @param _key hash of feed name\n    /// @return price\n    function getPrice(bytes32 _key) external view returns (uint128 price);\n\n    /// @notice method will revert if data for `_key` not exists.\n    /// @param _key hash of feed name\n    /// @return price\n    /// @return timestamp\n    function getPriceTimestamp(bytes32 _key) external view returns (uint128 price, uint32 timestamp);\n\n    /// @notice method will revert if data for `_key` not exists.\n    /// @param _key hash of feed name\n    /// @return price\n    /// @return timestamp\n    /// @return heartbeat\n    function getPriceTimestampHeartbeat(bytes32 _key)\n        external\n        view\n        returns (uint128 price, uint32 timestamp, uint24 heartbeat);\n\n    /// @dev This method should be used only for Layer2 as it is more gas consuming than others views.\n    /// @notice It does not revert on empty data.\n    /// @param _name string feed name\n    /// @return data PriceData\n    function getPriceDataByName(string calldata _name) external view returns (PriceData memory data);\n\n    /// @dev decimals for prices stored in this contract\n    function DECIMALS() external view returns (uint8); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/onChainFeeds/UmbrellaFeedsReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IUmbrellaFeeds.sol\";\n\n/// @dev This is optional price reader for just one feed.\n/// It comes with chanilink interface that makes migration process easier.\n/// For maximum gas optimisation it is recommended to use UmbrellaFeeds directly - simply follow this contract as\n/// a guide for integration.\n///\n/// This contract has build in fallback feature in case, `UmbrellaFeeds` will be replaced by newer contract.\n/// Fallback is transparent for the user, no additional setup is needed.\n///\n/// How fallback feature works? If data for provided key is empty (when UmbrellaFeeds was destroyed and replaced),\n/// contract will execute following procedure:\n/// 1. if data is empty, contract will check if there is new registered contract with requested data\n/// 2. if data is found in new contract it will be returned\n/// 3. if there is no data or there is no new contract tx will revert.\ncontract UmbrellaFeedsReader {\n    /// @dev Registry contract where list of all addresses is stored. Fallback feature uses this registry to\n    /// resolve newest `UmbrellaFeeds` address\n    IRegistry public immutable REGISTRY;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev contract where all the feeds are stored\n    address public immutable UMBRELLA_FEEDS;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev key (hash of string key), under which feed is being stored\n    bytes32 public immutable KEY;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev string representation of feed key (feed name)\n    string public description;\n\n    /// @dev decimals for feed\n    uint8 internal immutable _DECIMALS;  // solhint-disable-line var-name-mixedcase\n\n    error EmptyAddress();\n    error FeedNotExist();\n\n    /// @param _registry IRegistry address\n    /// @param _umbrellaFeeds UmbrellaFeeds address\n    /// @param _key price data key (before hashing)\n    constructor(IRegistry _registry, IUmbrellaFeeds _umbrellaFeeds, string memory _key) {\n        if (address(_registry) == address(0)) revert EmptyAddress();\n\n        REGISTRY = _registry;\n        UMBRELLA_FEEDS = address(_umbrellaFeeds);\n        description = _key;\n        _DECIMALS = _umbrellaFeeds.DECIMALS();\n\n        bytes32 hash = keccak256(abi.encodePacked(_key));\n        KEY = hash;\n\n        // sanity check\n        _umbrellaFeeds.getPriceData(hash);\n    }\n\n    /// @dev decimals for feed\n    function decimals() external view returns (uint8) {\n        return _DECIMALS;\n    }\n\n    /// @dev this method follows chainlink interface for easy migration, NOTE: not all returned data are covered!\n    /// latestRoundData() raise exception when there is no data, instead of returning unset values,\n    /// which could be misinterpreted as actual reported values.\n    /// It DOES NOT raise when data is outdated (based on heartbeat and timestamp).\n    /// @notice You can save some gas by doing call directly to `UMBRELLA_FEEDS` contract.\n    /// @return uint80 originally `roundId`, not in use, always 0\n    /// @return answer price\n    /// @return uint256 originally `startedAt`, not in use, always 0\n    /// @return updatedAt last timestamp data was updated\n    /// @return uint80 originally `answeredInRound` not in use, always 0\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 /* roundId */,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        )\n    {\n        IUmbrellaFeeds.PriceData memory priceData = _getPriceDataRaw();\n        return (0, int256(uint256(priceData.price)), 0, priceData.timestamp, 0);\n    }\n\n    /// @dev this is main endpoint for reading feed. Feed is read from UmbrellaFeeds contract using hardcoded `KEY`.\n    /// In case timestamp is empty (that means there is no data), contract will execute fallback call.\n    /// @notice revert on empty data\n    function getPriceData() external view returns (IUmbrellaFeeds.PriceData memory priceData) {\n        priceData = _getPriceDataRaw();\n\n        if (priceData.timestamp == 0) {\n            priceData = _fallbackCall();\n        }\n    }\n\n    /// @dev same as `getPriceData` but does not revert when no data\n    function getPriceDataRaw() external view returns (IUmbrellaFeeds.PriceData memory priceData) {\n        priceData = _getPriceDataRaw();\n\n        if (priceData.timestamp == 0) {\n            return _fallbackCallRaw();\n        }\n    }\n\n    /// @dev same as `getPriceData` but does not revert when no data\n    function _getPriceDataRaw() internal view returns (IUmbrellaFeeds.PriceData memory priceData) {\n        (bool success, bytes memory data) = UMBRELLA_FEEDS.staticcall(\n            abi.encodeWithSelector(IUmbrellaFeeds.prices.selector, KEY)\n        );\n\n        if (success && data.length != 0) {\n            priceData = abi.decode(data, (IUmbrellaFeeds.PriceData));\n        }\n    }\n\n    /// @dev it will revert on empty data\n    function _fallbackCall() internal view returns (IUmbrellaFeeds.PriceData memory data) {\n        address umbrellaFeeds = REGISTRY.getAddressByString(\"UmbrellaFeeds\");\n\n        // if contract was NOT updated, fallback is not needed, data does not exist - revert\n        if (umbrellaFeeds == UMBRELLA_FEEDS) revert FeedNotExist();\n\n        data = IUmbrellaFeeds(umbrellaFeeds).getPriceData(KEY);\n    }\n\n    /// @dev it will not revert on empty data\n    function _fallbackCallRaw() internal view returns (IUmbrellaFeeds.PriceData memory data) {\n        address umbrellaFeeds = REGISTRY.getAddressByString(\"UmbrellaFeeds\");\n\n        // if contract was updated, we do fallback\n        if (umbrellaFeeds != UMBRELLA_FEEDS) {\n            data = IUmbrellaFeeds(umbrellaFeeds).prices(KEY);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 0
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}