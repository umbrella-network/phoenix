{"language":"Solidity","sources":{"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"contracts/interfaces/IStakingBank.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingBank is IERC20 {\n    /// @param id address of validator wallet\n    /// @param location URL of the validator API\n    struct Validator {\n        address id;\n        string location;\n    }\n\n    event LogValidatorRegistered(address indexed id);\n    event LogValidatorUpdated(address indexed id);\n    event LogValidatorRemoved(address indexed id);\n    event LogMinAmountForStake(uint256 minAmountForStake);\n\n    /// @dev setter for `minAmountForStake`\n    function setMinAmountForStake(uint256 _minAmountForStake) external;\n\n    /// @dev allows to stake `token` by validators\n    /// Validator needs to approve StakingBank beforehand\n    /// @param _value amount of tokens to stake\n    function stake(uint256 _value) external;\n\n    /// @dev notification about approval from `_from` address on UMB token\n    /// Staking bank will stake max approved amount from `_from` address\n    /// @param _from address which approved token spend for IStakingBank\n    function receiveApproval(address _from) external returns (bool success);\n\n    /// @dev withdraws stake tokens\n    /// it throws, when balance will be less than required minimum for stake\n    /// to withdraw all use `exit`\n    function withdraw(uint256 _value) external returns (bool success);\n\n    /// @dev unstake and withdraw all tokens\n    function exit() external returns (bool success);\n\n    /// @dev creates (register) new validator\n    /// @param _id validator address\n    /// @param _location location URL of the validator API\n    function create(address _id, string calldata _location) external;\n\n    /// @dev removes validator\n    /// @param _id validator wallet\n    function remove(address _id) external;\n\n    /// @dev updates validator location\n    /// @param _id validator wallet\n    /// @param _location new validator URL\n    function update(address _id, string calldata _location) external;\n\n    /// @return total number of registered validators (with and without balance)\n    function getNumberOfValidators() external view returns (uint256);\n\n    /// @dev gets validator address for provided index\n    /// @param _ix index in array of list of all validators wallets\n    function addresses(uint256 _ix) external view returns (address);\n\n    /// @param _id address of validator\n    /// @return id address of validator\n    /// @return location URL of validator\n    function validators(address _id) external view returns (address id, string memory location);\n}\n"},"contracts/interfaces/StakingBankStaticNotSupported.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./IStakingBank.sol\";\n\nabstract contract StakingBankStaticNotSupported is IStakingBank {\n    error NotSupported();\n\n    function create(address, string calldata) external pure {\n        revert NotSupported();\n    }\n\n    function update(address, string calldata) external pure {\n        revert NotSupported();\n    }\n\n    function remove(address) external pure {\n        revert NotSupported();\n    }\n\n    function transfer(address, uint256) external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function transferFrom(address, address, uint256) external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function receiveApproval(address) external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function allowance(address, address) external pure returns (uint256) {\n        revert NotSupported();\n    }\n\n    function approve(address, uint256) external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function stake(uint256) external pure {\n        revert NotSupported();\n    }\n\n    function withdraw(uint256) external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function exit() external pure returns (bool) {\n        revert NotSupported();\n    }\n\n    function setMinAmountForStake(uint256) external pure {\n        revert NotSupported();\n    }\n}\n"},"contracts/stakingBankStatic/StakingBankStatic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/StakingBankStaticNotSupported.sol\";\n\n/// @dev Because we are using PoA in UMB oracle, staked balance does not matter. What's matter is, if signer is\n/// validator or not. In this case  we can optimise `StakingBank` and make it static for better gas performance.\nabstract contract StakingBankStatic is StakingBankStaticNotSupported {\n    uint256 public constant ONE = 1e18;\n\n    uint256 public immutable NUMBER_OF_VALIDATORS; // solhint-disable-line var-name-mixedcase\n    uint256 public immutable TOTAL_SUPPLY; // solhint-disable-line var-name-mixedcase\n\n    constructor(uint256 _validatorsCount) {\n        NUMBER_OF_VALIDATORS = _validatorsCount;\n        TOTAL_SUPPLY = _validatorsCount * ONE;\n\n        _assertValidSetup(_validatorsCount);\n    }\n\n    function balances(address _validator) external view returns (uint256) {\n        return _isValidator(_validator) ? ONE : 0;\n    }\n\n    function verifyValidators(address[] calldata _validators) external view returns (bool) {\n        for (uint256 i; i < _validators.length;) {\n            if (!_isValidator(_validators[i])) return false;\n            unchecked { i++; }\n        }\n\n        return true;\n    }\n\n    function getNumberOfValidators() external view returns (uint256) {\n        return NUMBER_OF_VALIDATORS;\n    }\n\n    function getAddresses() external view returns (address[] memory) {\n        return _addresses();\n    }\n\n    function getBalances() external view returns (uint256[] memory allBalances) {\n        allBalances = new uint256[](NUMBER_OF_VALIDATORS);\n\n        for (uint256 i; i < NUMBER_OF_VALIDATORS;) {\n            allBalances[i] = ONE;\n\n            unchecked {\n                // we will not have enough data to overflow\n                i++;\n            }\n        }\n    }\n\n    function addresses(uint256 _ix) external view returns (address) {\n        return _addresses()[_ix];\n    }\n\n    function validators(address _id) external view virtual returns (address id, string memory location);\n\n    /// @dev to follow ERC20 interface\n    function balanceOf(address _account) external view returns (uint256) {\n        return _isValidator(_account) ? ONE : 0;\n    }\n\n    /// @dev to follow ERC20 interface\n    function totalSupply() external view returns (uint256) {\n        return TOTAL_SUPPLY;\n    }\n\n    /// @dev to follow Registrable interface\n    function getName() external pure returns (bytes32) {\n        return \"StakingBank\";\n    }\n\n    /// @dev to follow Registrable interface\n    function register() external pure {\n        // there are no requirements atm\n    }\n\n    /// @dev to follow Registrable interface\n    function unregister() external pure {\n        // there are no requirements atm\n    }\n\n    function _addresses() internal view virtual returns (address[] memory);\n\n    function _isValidator(address _validator) internal view virtual returns (bool);\n\n    function _assertValidSetup(uint256 _validatorsCount) internal view virtual{\n        address[] memory list = _addresses();\n        require(list.length == _validatorsCount);\n\n        for (uint256 i; i < _validatorsCount;) {\n            require(_isValidator(list[i]));\n\n            unchecked { i ++; }\n        }\n    }\n}\n"},"contracts/stakingBankStatic/StakingBankStaticDev.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./StakingBankStatic.sol\";\n\n\ncontract StakingBankStaticDev is StakingBankStatic {\n    address public constant VALIDATOR_0 = 0xDc3eBc37DA53A644D67E5E3b5BA4EEF88D969d5C;\n    address public constant VALIDATOR_1 = 0x998cb7821e605cC16b6174e7C50E19ADb2Dd2fB0;\n\n    constructor(uint256 _validatorsCount) StakingBankStatic(_validatorsCount) {}\n\n    function validators(address _id) external pure override returns (address id, string memory location) {\n        if (_id == VALIDATOR_0) return (_id, \"https://validator.dev.umb.network\");\n        if (_id == VALIDATOR_1) return (_id, \"https://validator2.dev.umb.network\");\n\n        return (address(0), \"\");\n    }\n\n    function _addresses() internal view override returns (address[] memory) {\n        address[] memory list = new address[](NUMBER_OF_VALIDATORS);\n\n        list[0] = VALIDATOR_0;\n        list[1] = VALIDATOR_1;\n\n        return list;\n    }\n\n    function _isValidator(address _validator) internal pure override returns (bool) {\n        return (_validator == VALIDATOR_0 || _validator == VALIDATOR_1);\n    }\n}\n"}},"settings":{"optimizer":{"enabled":false,"runs":0},"outputSelection":{"contracts/stakingBankStatic/StakingBankStaticDev.sol":{"StakingBankStaticDev":["*"]}},"metadata":{"useLiteralContent":true},"libraries":{}}}