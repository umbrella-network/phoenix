{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n\ninterface IRegistry {\n    event LogRegistered(address indexed destination, bytes32 name);\n\n    /// @dev imports new contract addresses and override old addresses, if they exist under provided name\n    /// This method can be used for contracts that for some reason do not have `getName` method\n    /// @param  _names array of contract names that we want to register\n    /// @param  _destinations array of contract addresses\n    function importAddresses(bytes32[] calldata _names, address[] calldata _destinations) external;\n\n    /// @dev imports new contracts and override old addresses, if they exist.\n    /// Names of contracts are fetched directly from each contract by calling `getName`\n    /// @param  _destinations array of contract addresses\n    function importContracts(address[] calldata _destinations) external;\n\n    /// @dev this method ensure, that old and new contract is aware of it state in registry\n    /// Note: BSC registry does not have this method. This method was introduced in later stage.\n    /// @param _newContract address of contract that will replace old one\n    function atomicUpdate(address _newContract) external;\n\n    /// @dev similar to `getAddress` but throws when contract name not exists\n    /// @param name contract name\n    /// @return contract address registered under provided name or throws, if does not exists\n    function requireAndGetAddress(bytes32 name) external view returns (address);\n\n    /// @param name contract name in a form of bytes32\n    /// @return contract address registered under provided name\n    function getAddress(bytes32 name) external view returns (address);\n\n    /// @param _name contract name\n    /// @return contract address assigned to the name or address(0) if not exists\n    function getAddressByString(string memory _name) external view returns (address);\n\n    /// @dev helper method that converts string to bytes32,\n    /// you can use to to generate contract name\n    function stringToBytes32(string memory _string) external pure returns (bytes32 result);\n}\n"
    },
    "contracts/interfaces/IStakingBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingBank is IERC20 {\n    /// @param id address of validator wallet\n    /// @param location URL of the validator API\n    struct Validator {\n        address id;\n        string location;\n    }\n\n    event LogValidatorRegistered(address indexed id);\n    event LogValidatorUpdated(address indexed id);\n    event LogValidatorRemoved(address indexed id);\n    event LogMinAmountForStake(uint256 minAmountForStake);\n\n    /// @dev setter for `minAmountForStake`\n    function setMinAmountForStake(uint256 _minAmountForStake) external;\n\n    /// @dev allows to stake `token` by validators\n    /// Validator needs to approve StakingBank beforehand\n    /// @param _value amount of tokens to stake\n    function stake(uint256 _value) external;\n\n    /// @dev notification about approval from `_from` address on UMB token\n    /// Staking bank will stake max approved amount from `_from` address\n    /// @param _from address which approved token spend for IStakingBank\n    function receiveApproval(address _from) external returns (bool success);\n\n    /// @dev withdraws stake tokens\n    /// it throws, when balance will be less than required minimum for stake\n    /// to withdraw all use `exit`\n    function withdraw(uint256 _value) external returns (bool success);\n\n    /// @dev unstake and withdraw all tokens\n    function exit() external returns (bool success);\n\n    /// @dev creates (register) new validator\n    /// @param _id validator address\n    /// @param _location location URL of the validator API\n    function create(address _id, string calldata _location) external;\n\n    /// @dev removes validator\n    /// @param _id validator wallet\n    function remove(address _id) external;\n\n    /// @dev updates validator location\n    /// @param _id validator wallet\n    /// @param _location new validator URL\n    function update(address _id, string calldata _location) external;\n\n    /// @return total number of registered validators (with and without balance)\n    function getNumberOfValidators() external view returns (uint256);\n\n    /// @dev gets validator address for provided index\n    /// @param _ix index in array of list of all validators wallets\n    function addresses(uint256 _ix) external view returns (address);\n\n    /// @param _id address of validator\n    /// @return id address of validator\n    /// @return location URL of validator\n    function validators(address _id) external view returns (address id, string memory location);\n}\n"
    },
    "contracts/interfaces/IUmbrellaFeeds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev Main contract for all deviation triggered fees.\n/// This contract has build in fallback feature in case it will be replaced by newer version.\n/// Fallback is transparent for the user, no additional setup is needed.\n///\n/// How fallback feature works? If data for provided key is empty, contract will execute following procedure:\n/// 1. triggered feeds, that needs to be updated will be updated in new contract and erased from this one\n/// 2. if data is empty, check, if new deployment of UmbrellaFeeds is done, if not stop.\n/// 3. forward the call to that new contract.\n///\n/// After new deployment done it is recommended to update address to avoid fallback and reduce gas cost.\n/// In long run this is most efficient solution, better than any proxy.\ninterface IUmbrellaFeeds {\n    struct PriceData {\n        uint8 data;\n        uint24 heartbeat;\n        uint32 timestamp;\n        uint128 price;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @dev method for submitting consensus data\n    /// @param _priceKeys array of keys for `_priceDatas`\n    /// @param _priceDatas PriceData signed by validators\n    /// @param _signatures validators signatures\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function update(\n        bytes32[] calldata _priceKeys,\n        PriceData[] calldata _priceDatas,\n        Signature[] calldata _signatures\n    ) external;\n\n    /// @dev method for resetting data\n    /// @param _priceKeys array of keys for `_priceDatas`\n    /// @param _signatures validators signatures\n    function reset(bytes32[] calldata _priceKeys, Signature[] calldata _signatures) external;\n\n    /// @dev it will return array of price datas for provided `_keys`\n    /// In case ony of feeds timestamp is empty, fallback call will be executed for that feed.\n    /// If any of feeds fallback calls fail, function will revert.\n    /// @param _keys array of feed keys\n    /// @return data PriceData array\n    function getPricesData(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev same as getPricesData() but does not revert on empty data.\n    function getPricesDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\n\n    /// @dev this is main endpoint for reading feeds.\n    /// In case timestamp is empty (that means there is no data), contract will execute fallback call.\n    /// Check contract description for fallback details.\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data);\n\n    /// @dev same as `getPriceData` but does not revert when no data\n    function getPriceDataRaw(bytes32 _key) external view returns (PriceData memory data);\n\n    function DECIMALS() external view returns (uint8); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/onChainFeeds/UmbrellaFeeds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interfaces/IUmbrellaFeeds.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IStakingBank.sol\";\n\n/// @dev Main contract for all deviation triggered fees.\n/// This contract has build in fallback feature in case it will be replaced by newer version.\n/// Fallback is transparent for the user, no additional setup is needed.\n///\n/// How fallback feature works? If data for provided key is empty, contract will execute following procedure:\n/// 1. triggered feeds, that needs to be updated will be updated in new contract and erased from this one\n/// 2. if data is empty, check, if new deployment of UmbrellaFeeds is done, if not stop.\n/// 3. forward the call to that new contract.\n///\n/// After new deployment done it is recommended to update address to avoid fallback and reduce gas cost.\n/// In long run this is most efficient solution, better than any proxy.\ncontract UmbrellaFeeds is IUmbrellaFeeds {\n    bytes constant public ETH_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\n    string constant public NAME = \"UmbrellaFeeds\";\n\n    IStakingBank public immutable STAKING_BANK;  // solhint-disable-line var-name-mixedcase\n    IRegistry public immutable REGISTRY;  // solhint-disable-line var-name-mixedcase\n\n    /// @dev minimal number of signatures required for accepting submission (PoA)\n    uint16 public immutable REQUIRED_SIGNATURES; // solhint-disable-line var-name-mixedcase\n\n    /// @dev decimals for prices stored in this contract\n    uint8 public immutable DECIMALS;  // solhint-disable-line var-name-mixedcase\n\n    mapping (bytes32 => PriceData) public prices;\n\n    error ArraysDataDoNotMatch();\n    error FeedNotExist();\n    error FallbackFeedNotExist();\n    error NotEnoughSignatures();\n    error InvalidRequiredSignatures();\n    error SignaturesOutOfOrder();\n    error OldData();\n\n    /// @param _contractRegistry Registry address\n    /// @param _requiredSignatures number of required signatures for accepting consensus submission\n    /// @param _decimals decimals for prices stored in this contract\n    constructor(\n        IRegistry _contractRegistry,\n        uint16 _requiredSignatures,\n        uint8 _decimals\n    ) {\n        if (_requiredSignatures == 0) revert InvalidRequiredSignatures();\n\n        REGISTRY = _contractRegistry;\n        REQUIRED_SIGNATURES = _requiredSignatures;\n        STAKING_BANK = IStakingBank(_contractRegistry.requireAndGetAddress(\"StakingBank\"));\n        DECIMALS = _decimals;\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function update(\n        bytes32[] calldata _priceKeys,\n        PriceData[] calldata _priceDatas,\n        Signature[] calldata _signatures\n    ) external {\n        // below two checks are only for pretty errors, so we can safe gas and allow for raw revert\n        // if (_priceKeys.length != _priceDatas.length) revert ArraysDataDoNotMatch();\n\n        bytes32 priceDataHash = keccak256(abi.encode(_priceKeys, _priceDatas));\n        verifySignatures(priceDataHash, _signatures);\n\n        uint256 i;\n\n        while (i < _priceDatas.length) {\n            // we do not allow for older prices\n            // at the same time it prevents from reusing signatures\n            if (prices[_priceKeys[i]].timestamp >= _priceDatas[i].timestamp) revert OldData();\n\n            prices[_priceKeys[i]] = _priceDatas[i];\n\n            // atm there is no need for events, so in order to save gas, we do not emit any\n            unchecked { i++; }\n        }\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function reset(bytes32[] calldata _priceKeys, Signature[] calldata _signatures) external {\n        bytes32 resetHash = keccak256(abi.encodePacked(_priceKeys, \"RESET\"));\n        verifySignatures(resetHash, _signatures);\n\n        for (uint256 i; i < _priceKeys.length;) {\n            delete prices[_priceKeys[i]];\n            // atm there is no need for events, so in order to save gas, we do not emit any\n            unchecked { i++; }\n        }\n    }\n\n    /// @dev method for submitting consensus data\n    /// @param _hash hash of signed data\n    /// @param _signatures array of validators signatures\n    // ss solhint-disable-next-line function-max-lines, code-complexity\n    function verifySignatures(bytes32 _hash, Signature[] calldata _signatures) public view {\n        address prevSigner = address(0x0);\n\n        if (_signatures.length < REQUIRED_SIGNATURES) revert NotEnoughSignatures();\n\n        // to save gas we check only required number of signatures\n        // case, where you can have part of signatures invalid but still enough valid in total is not supported\n        for (uint256 i; i < REQUIRED_SIGNATURES;) {\n            address signer = recoverSigner(_hash, _signatures[i].v, _signatures[i].r, _signatures[i].s);\n            if (prevSigner >= signer) revert SignaturesOutOfOrder();\n\n            // because we check only required number of signatures, any invalid one will cause revert\n            if (STAKING_BANK.balanceOf(signer) == 0) revert NotEnoughSignatures();\n\n            prevSigner = signer;\n\n            unchecked { i++; }\n        }\n    }\n\n    /// @param _hash hashed of data\n    /// @param _v part of signature\n    /// @param _r part of signature\n    /// @param _s part of signature\n    /// @return signer address\n    function recoverSigner(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(ETH_PREFIX, _hash));\n        return ecrecover(hash, _v, _r, _s);\n    }\n\n    /// @dev helper method for QA purposes\n    /// @return hash of data that are signed by validators (keys and priced data)\n    function hashSubmitData(bytes32[] calldata _priceKeys, PriceData[] calldata _priceDatas)\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_priceKeys, _priceDatas));\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function getPricesData(bytes32[] calldata _keys) external view returns (PriceData[] memory data) {\n        data = new PriceData[](_keys.length);\n\n        for (uint256 i; i < _keys.length;) {\n            data[i] = prices[_keys[i]];\n\n            if (data[i].timestamp == 0) {\n                data[i] = _fallbackCall(_keys[i]);\n            }\n\n            unchecked { i++; }\n        }\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function getPricesDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data) {\n        data = new PriceData[](_keys.length);\n\n        for (uint256 i; i < _keys.length;) {\n            data[i] = prices[_keys[i]];\n\n            if (data[i].timestamp == 0) {\n                data[i] = _fallbackCallRaw(_keys[i]);\n            }\n\n            unchecked { i++; }\n        }\n    }\n\n    /// @dev this is only for dev debug,\n    /// please use `getPriceData` directly for lower has cost and fallback functionality\n    function priceData(string memory _key) external view returns (PriceData memory) {\n        return prices[keccak256(abi.encodePacked(_key))];\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data) {\n        data = prices[_key];\n\n        if (data.timestamp == 0) {\n            data = _fallbackCall(_key);\n        }\n    }\n\n    /// @inheritdoc IUmbrellaFeeds\n    function getPriceDataRaw(bytes32 _key) external view returns (PriceData memory data) {\n        data = prices[_key];\n\n        if (data.timestamp == 0) {\n            data = _fallbackCallRaw(_key);\n        }\n    }\n\n    /// @dev to follow Registrable interface\n    function getName() public pure returns (bytes32) {\n        return \"UmbrellaFeeds\";\n    }\n\n    function _fallbackCall(bytes32 _key) internal view returns (PriceData memory) {\n        address umbrellaFeeds = REGISTRY.getAddressByString(NAME);\n\n        // if contract was NOT updated - revert\n        if (umbrellaFeeds == address(this)) revert FeedNotExist();\n\n        return UmbrellaFeeds(umbrellaFeeds).getPriceDataRaw(_key);\n    }\n\n    function _fallbackCallRaw(bytes32 _key) internal view returns (PriceData memory data) {\n        address umbrellaFeeds = REGISTRY.getAddress(getName());\n\n        // if contract was updated, we do a fallback call\n        if (umbrellaFeeds != address(this) && umbrellaFeeds != address(0)) {\n            return UmbrellaFeeds(umbrellaFeeds).getPriceDataRaw(_key);\n        }\n\n        // else - we return empty data\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 0
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}